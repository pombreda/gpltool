TODO:

file systems:
* FAT
* NTFS
* ubifs (unubi was removed from mtd-utils)
* more generic YAFFS2 support
* squashfs as described at http://www.devttys0.com/2011/08/extracting-non-standard-squashfs-images/

compression:
* rzip
* E00
* 7z only works if a whole file is compressed with 7z. Rework and test with D-Link firmware DSL-524T_FW_V3.00B01T02.UK-A.20060621.zip
* create workaround for https://bugzilla.redhat.com/show_bug.cgi?id=907442
* pack200 (unzip)

queueing system:
* let top level script also read from a queue
* add script to add files to and remove files from scanning queue

aggregate scanning:
* cleanup if we used one of the squashfs + lzma variants where we can't determine the size.
* add scan for reporting duplicate files
* report possible whole chain of dependencies for a program

GUI:
* rewrite to PyQt or PySide to take advantage of better rendering engine (webkit)

error handling:
* better handle errors to give users a better indication if something went wrong

function names:
* generate list of function names and where they were found, optionally with line numbers, for GUI

database creation:
* rename batchextractprogramstrings.py
* replace excessive parameter list of batchextractprogramstrings.py with a configuration file
* handle embedded archives (ZIP files, tarballs, etc.)
* handle patches
* import licensing information from SPDX files
* rewrite ctags and xgettext invocations to scan multiple files at once to reduce overhead of calling ctags and xgettext
* create index for sha256 for processed

ranking:
* use version information to report most likely licenses
* report correlation between packages (strings, variable names, function names) to detect cloning in the database
* store info about unique strings more efficiently since often they don't change in between versions. This is to reduce memory usage.
* deal with inner classes properly
* use clonedb information for variable names, field names, and so on
* use information from special ELF sections from Linux kernels that are distributed as ELF files, such as Fedora's kernels, or Linux kernel modules: __ksymtab + friends and .symtab

bat-extratools:
* add patches for CVE-2012-4024 for unsquashfs42

busybox scanning:
* clean up finding ranges of applets in extract_configuration. It should be possible to do this less kludgy.

HTML generation:
* finish function name reporting
* clean up/rewrite/make it easier to use
* add license information if available

misc:
* replay script to unpack firmware based on only the pickle with unpacking data
* expand "debug"
* add support for ignoring some file types/extensions completely
* store duplicate pictures as symlinks instead of making a copy. If the results are to be viewed on Windows this might not be a good idea but if it is only viewed on Linux it could be a big save.

BOTTLENECKS:
1. ELF tagging is sometimes incorrect, so LZMA unpacker tries to extract LZMA files in vain from these ELF files, which costs a lot of time.
2. There can be a lot of duplication in generating the pictures, especially the version charts. In one of my test cases there are several thousands of duplicates. To avoid this an aggregate scan should first write the individual pickles and store what they belong to (possibly in parallel, but then there might be race conditions). Then the aggregatescan should generate the pictures in parallel (using a Pool of its own).
3. After 2. it makes sense to let ranking (or the aggregate scan of 2) write data that rankimages.py can use to generate piecharts. This way rankimages.py would not have to read pickles, or only would have to read significantly smaller pickles.
4. preread (in parallel) leafreports of Java .class files which are shared between several JAR files for aggregate jars. This saves opening and reading the same files.
5. make findlibs.py partially parallel
