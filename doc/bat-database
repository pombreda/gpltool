Using/updating the BAT database

BAT comes with a mechanism to use a database backend. The default version of
BAT only unpacks file systems and compressed files and runs a few simple checks
on the leaf nodes of the unpacking process.

In the paper "Finding Software License Violations Through Binary Code Clone
Detection" by Hemel et. al. (ACM 978-1-4503-0574-7/11/05) presented at
the Mining Software Repositories 2011 conference a method to use a database
with strings extracted from source code was described. This functionality is
is available in the ranking module in the file "ranking.py". This code is not
enabled by default, but it has to be explicitely enabled in the configuration.

To give good results the database that is used needs to be populated with as
many packages as possible, from a cross cut of all of open source software, to
prevent bias towards certain packages: if you only would have BusyBox in your
database, everything would look like BusyBox.

To populate the database you need to download and process open source packages.
Be aware that this is a costly operation: a download of all source packages of
a snapshot of Debian (which would give you a few versions for most packages) is
about 60 GiB. Together with all of GNU, GNOME, most BusyBox versions, and a few
versions of KDE you have about 100 GiB of compressed source code archives.
Processing these files (including licensing information) will take a long time
and the resulting database will also be quite big (at least around 20 GiB).

If you don't want to spend much time on downloading packages and processing
these packages, please contact Tjaldur Software Governance Solutions for
purchasing a copy of a fully preprocessed database at <info@tjaldur.nl>.

  Crawling FTP mirrors

In the directory 'crawlers' a sample crawler is given for downloading packages
from the GNU project. The code is fairly straightforward. The script (written
in Python) tries to intelligently download packages from a GNU FTP mirror,
skipping packages that are in a blacklist (either parts of the filename, whole
directories, or extensions) or that have already been downloaded.

NOTE: please update the location of the GNU mirror in the configuration file!
specifying a local mirror will result in faster downloads. It will also not put
an unnecessary strain on the FTP mirror mentioned in that file!

  Generating the package list

The code and license extractor wants a description file of which packages to
process. This file is hardcoded to "LIST" relative to the directory that
contains all source archives. The reason we have a specific file is that some
packages do not follow a consistent naming scheme.

The file contains four values per line:

* name
* version
* archivename
* origin (or "unknown" if not specified)

separated by whitespace (spaces or tabs), for example:

amarok	2.3.2	amarok-2.3.2.tar.bz2	kde

There is a helper script (generatelist.py) to help generate the file. It is
advised to manually inspect the file after generating it to ensure the
correctness of the package names.

Packages can have been renamed for a variety of reasons:

* upstream decided to use a new name for archives (abiword archives were
renamed from "abi-$VERSION.tar.gz" to "abiword-$VERSION.tar.gz")
* a distribution renames packages to avoid clashes during installation and
allow different versions to be installed next to eachother

In these cases you need to change the names, otherwise different versions of the
same package will be recorded in the database as different packages, which will
confuse the rating algorithm and cause it to give suboptimal results.

  Running the extraction program

The extraction program (batchextractprogramstrings.py) uses xgettext to extract
all strings between double quotes from source code. These are the strings that
are likely to end up in a binary. The batchextractprogramstrings.py script
simply wraps around a call to xgettext and parses the results.

$ python batchextractprogramstrings.py -f /path/to/directory/with/files -d /path/to/database

  License scanning

batchextractprogramstrings.py has a few options. The most important is whether
or not to also extract licenses from the source code files. License extraction
is done using the Ninka license scanner, with future support for Nomos from
FOSSology being added in the future. This option is disabled by default for a
few reasons:

* scanning licenses adds a significant performance penalty on scanning the code
(about 1100% when scanning uClibc 0.9.30.1), even with many optimizations
(deduplication) in place
* there is currently no code that can make use of this information

If you want to enable license scanning, you will have to install Ninka first
and change a few hardcode paths in batchextractprogramstrings.py that point to
the main Ninka script.

  Intelligently making sets of packages when using multiple machines

One way to tackle the tackle the problem of having to process huge amounts of
source code is to use multiple machines and later merge database. By adding a
little bit of intelligence to preparing the sets of source packages you can
save a lot of processing time. Many packages have duplicate files, especially
if they are just different versions of the same package. A minor patch version
could differ as much as one file. If the extractor already has seen a file, it
will not scan it again, so it makes sense to have as many similar packages
scanned on the same machine, for example all versions of a single package. If
license scanning is enabled it makes sense to have as many packages from the
same project scanned on the same machine, since coding styles often result in
identical license statements, which the scanner already takes into account.

  Enabling the database

Currently the database is hardcoded to '/tmp/master'. It can be changed in
ranking.py in the following line:

  conn = sqlite3.connect(os.environ.get('BAT_SQLITE_DB', '/tmp/master'))

In the future it will be possible to set the location of the database through
the configuration file.
