\documentclass[10pt]{article}
\usepackage{url}
\usepackage{a4}

\pagestyle{empty}

\setlength{\parskip}{4pt}

\author{Armijn Hemel -- Tjaldur Software Governance Solutions}
\title{Binary Analysis Tool User Manual}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Introducing the Binary Analysis Tool}

The Binary Analysis Tool is a tool that 

\subsection{Software requirements}

\subsection{Hardware requirements}

The tools in the Binary Analysis Tool can be quite resource intensive. Most of
the tools seem to be memorybound and I/O-bound, so it makes more sense to
invest in more memory and faster disks (SSD) than in raw CPU power.

\section{Design of the Binary Analysis Tool}

BAT consists of several scripts written in Python.

\subsection{\texttt{bruteforce.py}}

The main program in BAT is the \texttt{bruteforce.py} tool. It takes a brute
force approach to scanning a binary and has no prior knowledge of how a binary
is constructed. Instead it finds out by applying several methods, like
searching for known identifiers. It then unpacks compressed files, media files
and file systems recursively and finally applies a wide range of individual
scans to each unpacked file.

\subsubsection{Unpack scans}

In BAT currently the following file systems, compressed files and media files
can be unpacked:

\begin{itemize}
\item file systems: cramfs, ext2/ext3/ext4, ISO9660, JFFS2, SquashFS (specific
variants), UBIFS
\item compressed files: ar, ARJ, BASE64, BZIP2, compressed Flash, CAB, CPIO,
EXE (specific compression methods only) GZIP, InstallShield (old versions),
LZIP, LZMA, LZO, RAR, RPM, TAR, XZ, ZIP
\item media files: GIF, ICO, PNG
\end{itemize}

The unpacking process differs per file type. Most files use one or more
identifier that can be looked for in a binary blob. Using this information it
is possible to carve out the right parts of a binary blob and verify if it
indeed contains a compressed file, media file or file system.

Not all files have a proper identifier. The YAFFS2 file system layout for
example is dependent on the hardware specifics of the underlying flash chip.

Other files (such as ARJ and ICO files) have a very generic identifier, so
there are a lot of false positives, which causes a big increase in runtime.

\subsubsection{Leaf scans}

Leaf scans, or program scans, are scans that are run on every single file
that has been unpacked, including files that contained files that were found
and extracted by unpack scans.

The current scans that are available in BAT are:

\begin{itemize}
\item fast string searches: BusyBox, dproxy, ez-ipupdate, iptables, iproute,
libusb, Linux kernel, loadlin, RedBoot, U-Boot, vsftpd, wireless-tools,
wpa-supplicant
\item advanced search mode using ranking (described in detail later)
\item dynamic library dependencies (ELF files only)
\item Linux kernel module license (Linux kernel modules only)
\end{itemize}

The fast string searches are meant for quick sweep scanning. These scans work
by scanning for a few well known marker strings that can be found in the
respective packages. They will not always match, but they are useful ..

\subsubsection{Enabling and disabling scans}

The \texttt{bruteforce.py} tool uses a configuration file that is in Windows
INI format. There is a default configuration file that enables most of the
scans by default. To disable a scan it can be outcommented in the file (by
starting the line with the \texttt{\#} character), or by removing it from the
configuration file.

\subsubsection{Blacklisting and priorities}

In BAT blacklists are used to prevent some scans from running on a particular
byte range, because other scans have already covered these bytes, or will cover
them.

The most obvious example is the ext2 file system: in a normal setup (no
encryption) it is trivial to see the content of all the individual files when
ax ext2 file system image is opened. This is because this file system is
mostly a concatenation of the data, with some meta data associated with the
files in the file system.

If another compressed file is in the ext2 file system it could be that it will
be picked up by BAT twice: once it will be detected inside the ext2 file system
and once after the file system has been unpacked by the ext2 file system
unpacker.

Other examples are:

\begin{itemize}
\item cpio (files are concatenated with a header and a trailer)
\item tar (files are concatenated with some meta data)
\item RPM (files are in a compressed archive with some meta data)
\item ar and DEB
\item some flavours of cramfs
\item ubifs
\end{itemize}

To avoid duplicate scanning and false positives it is therefore necessary to
prevent other scans from running on the byte range already covered by one of
these files.

In BAT this is achieved by using blacklists. All unpack scans have a parameter
called \texttt{blacklist} which is consulted everytime a file is unpacked. If
a file system offset is in a blacklist the scan could use the next offset, or
skip scanning the entire file, depending on the scan.

The blacklist is set for every file individually and is initially empty. If a
scan is successful it adds a byte range to the blacklist. Subsequent scans
will skip the byte range added by the scan.

The scans are run in a particular order to make the best use of blacklists. The
order of scans is determined by the \texttt{priority} parameter in the
configuration file. The file systems and concatenated files mentioned above
have a higher priority and are scanned earlier than other scans that could also
give a match. It is not a fool proof system, but it seems to work well enough.

\subsubsection{Pretty printing}

Pretty printing for unpack scans is standardized. For leaf scans there is more
flexibility. This is needed because in some cases the result as returned by
the leaf scan needs post processing.

A pretty printer can be defined in the configuration through the directive
\texttt{xmloutput}. The pretty printer should be in the same module as the
scanning method defined in the same section. The pretty printer has two
parameters: a Python datastructure as returned by the scanner (this differs
per scan) and a XML root element, needed to create new XML nodes. The method is
expected to return a XML node in case of success, or \texttt{None} in case of
failure.

If no pretty printer is defined the value as returned by the scan will be used
as the content of result tag.

\subsubsection{Interpreting the results}

\texttt{bruteforce.py} outputs its results as XML on standard output. After
redirecting the output to a file it is possible to look at this file using a
commandline tool such as \texttt{xml\_pp} or a webbrowser such as Mozilla
Firefox.

In the future a graphical user interface will be wrapped around BAT that will
make it easier to interpret the results in a more interactive way.

The XML file starts with metadata, such as:

\begin{itemize}
\item date, plus time of the scan (local time of the computer, in UTC)
\item name of the file
\item SHA256 cryptographic checksum of the file, uniquely identifying it
\item size of the file
\item filetype as determined by \texttt{file} on a Linux system
\item relative path inside the unpacked system, plus the absolute path inside
the file system, which is useful for later analysis
\end{itemize}

If any of the scans were successful the results of the individual scans will
be included in the element \texttt{scans}.

For each unpacking scans the following attributes are reported:

\begin{itemize}
\item name of the scan (corresponding to the name of the scan in the
configuration file)
\item offset in the parent file of the compressed file or file system
\end{itemize}

\subsection{\texttt{busybox-compare-configs.py}}

Another tool in BAT is \texttt{busybox-compare-configs.py} which is specifically
used to analyze BusyBox binaries. BusyBox is in widespread use on embedded
devices and the license on BusyBox is actively enforced.

The BusyBox binaries on these machines often have different configurations,
depending on the needs of the manufacturer. Since providing the correct
configuration is one of the requirements for license compliance it is important
to be able to determine the configuration of a BusyBox binary and verify that
there is a corresponding configuration file in the source code release.

The BusyBox processing tools in BAT try to extract the most likely
configuration from the binary and print it in the right format (which
depends on the BusyBox version).

\subsubsection{Detecting BusyBox}

The first step is determining if a binary is indeed BusyBox. This is trivial,
since in a BusyBox binary you will almost always find clear indication strings
if BusyBox is used (unless they have been specifically altered to hide the use
of BusyBox).

A significant string to look for is:

\begin{verbatim}
        BusyBox is a multi-call binary that combines many common Unix
        utilities into a single executable.  Most people will create a
        link to busybox for each function they wish to use and BusyBox
        will act like whatever it was invoked as!
\end{verbatim}

Another clear indicator is a BusyBox version string, for example:

\begin{verbatim}
BusyBox v1.15.2 (2009-12-03 00:14:42 CET)
\end{verbatim}

As an exception a BusyBox binary configured to include just a single applet
will not contain contain the marker strings, or the BusyBox version string. In
such a case a different detection mechanism will have to be used, for example
the ranking code as used in \texttt{bruteforce.py}, although this will only be
necessary in a very small percentage of cases, since the vast majority of
BusyBox instances include more than one applet.

\subsubsection{BusyBox version strings}

The BusyBox version strings have remained fairly consistent over the years:

\begin{verbatim}
BusyBox v1.00-rc2 (2006.09.14-03:08+0000) multi-call binary
BusyBox v1.1.3 (2009.09.11-12:49+0000) multi-call binary
BusyBox v1.15.2 (2009-12-03 00:14:42 CET)
\end{verbatim}

The time stamps in the version string are irrelevant, since they are generated
during build time and are not hardcoded in the source code.

Extracting version information from the BusyBox binary is not difficult.
Using regular expression it is possible to look for \texttt{BusyBox v} which
indicates the start of a BusyBox version string. The version number can be
found immediately following this substring until \texttt{ (} (including
leading space) is found.

Apart from reporting, the BusyBox version number is also used for other
things, such as determining the right configuration format and accessing a
knowledgebase of known applet names extracted from the standard BusyBox
releases from \url{busybox.net}.

\subsubsection{BusyBox configuration format}

During the compilation of BusyBox a configuration file is used to determine
which functionality will be included in the binary. The format of this
configuration file has changed a few times over the years. Early versions used
a simple header format file, with GNU C/C++ style defines. Later versions,
starting 1.00pre1, moved to Kbuild, the same configuration system as used by
for example the Linux kernel or OpenWrt. This format is still in use today
(BusyBox 1.19.2 being the latest version at the time of writing).

Each configuration directive determines whether or not a certain piece of
source code will be compiled and up in the BusyBox binary. This source code can
either be a full applet, or just a piece of functionality that merely extends
an existing applet.

\subsubsection{Methods for extracting a configuration from a BusyBox binary}

Extracting the BusyBox configuration from a binary is not entirely trivial.
There are a few methods which can be used:

\begin{enumerate}
\item run \texttt{busybox} (on a device, or inside a sandbox) and see what
functionality is reported. This is probably the most accurate method, but also
the hardest, since it requires access to a device, or a sandbox that has been
properly set up, with all the right dependencies, and so on.

When running \texttt{busybox} without any arguments, or with the \texttt{--help}
parameter it will output a list of functions that are defined inside the
binary:

\begin{verbatim}
Currently defined functions:
        ar, cal, cpio, dpkg, dpkg-deb, gunzip, zcat
\end{verbatim}

These can be mapped to a configuration, using information extracted from
BusyBox source code about which applets map to which configuration option.
\item extract the configuration from the binary by searching for known applet
names in the firmware. The end result is the same as a previous step, but
possibly with less accuracy in some cases but it is the only feasible solution
when you only have a binary.
\end{enumerate}

The BusyBox binary has a string embedded for every applet that is included.
This is the string that is printed out if \texttt{--help} is given as a
parameter to an invocation of \texttt{busybox}.

Using information about the configuration extracted from BusyBox source code
these strings can be mapped to a configuration directive and a possible
configuration can be reconstructed.

Depending on how the binary was compiled this can be trivial, or quite hard.

\subsubsection{Binaries linked with uClibc}

In binaries that link against uClibc (a particular C library) the name of the
main function of the applet is sometimes (but not always) included in the
\texttt{busybox} binary as follows (a good way is to run \texttt{strings} on
the binary and look at the output).

\begin{verbatim}
wget_main
\end{verbatim}

This string maps to the name of the main function for the \texttt{wget} applet
(\texttt{networking/wget.c}):

\begin{verbatim}
int wget_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
\end{verbatim}

The BusyBox authors are pretty strict in their naming and usually have a
configuration directive in the a specific format
(\texttt{CONFIG-\$appletname}) in the Makefile, like:

\begin{verbatim}
lib-$(CONFIG_WGET)         += wget.o
\end{verbatim}

(example taken from \texttt{networking/Kbuild} in BusyBox 1.15.2). There are
cases where the format could be slightly different.

\subsubsection{Binaries linked with glibc \& uClibc exceptions}

Sometimes the method described in the previous section does not work for
binaries that are linked with uClibc. It also does not work with binaries
compiled with glibc.

If the binary is unstripped and the binary still contains symbol information
it is possible to extract the right information using \texttt{readelf} (part
of GNU binutils) in a similar fashion as the earlier described method.

In case there is no information available it is still possible to search inside
the binary for the applet names. Because most instances of BusyBox that are
installed on devices have not been modified the list of applets in the stock
version of BusyBox serves as an excellent starting point.

The list as printed by \texttt{busybox} if the \texttt{--help} parameter is
given is embedded in the binary. The applet names are alphabetically sorted
and separated by NUL characters.

By searching for this list and splitting it accordingly it is possible to get
the list of all applets that are defined. The only caveats are that a new
applet that was added appears alphabetically before any of the applets that
can be recognized using a list of appletnames extracted from the source code,
or it appears alphabetically after the last one that can be recognized.

\subsubsection{Pretty printing a configuration}

Pretty printing a configuration is fairly straightforward, but there are a few
cases where it is hard to make a good guess:

\begin{enumerate}
\item aliases
\item functionality that is added to an applet, depending on a configuration directive
\item applets that use non-standard configuration names (like \texttt{CONFIG\_APP\_UDHCPD} instead of \texttt{CONFIG\_UDHCPD} in some versions of BusyBox)
\item features
\end{enumerate}

For some applets aliases are installed by default as symlinks. These aliases
are recorded in the binary, but there is no separate applet for it. In the
BusyBox sources (1.15.2, others might be different) these are defined as:

\begin{verbatim}
IF_CRYPTPW(APPLET_ODDNAME(mkpasswd, cryptpw, _BB_DIR_USR_BIN,
    _BB_SUID_DROP, mkpasswd))
\end{verbatim}

So if the \texttt{cryptw} tool is built, an additional symlink called
\texttt{mkpasswd} is added during installation.

If extra functionality is added to an applet in BusyBox it is defined in the
source code by macros like the following:

\begin{verbatim}
IF_SHA256SUM(APPLET_ODDNAME(sha256sum, md5_sha1_sum, _BB_DIR_USR_BIN,
    _BB_SUID_DROP, sha256sum))
IF_SHA512SUM(APPLET_ODDNAME(sha512sum, md5_sha1_sum, _BB_DIR_USR_BIN,
    _BB_SUID_DROP, sha512sum))
\end{verbatim}

The above configuration tells to add extra symlinks for \texttt{sha256sum} and
\texttt{sha512sum} if BusyBox is configured for suppport for the SHA256 and
SHA512 algorithms. The applet that implements this functionality is
\texttt{md5\_sha1\_sum}.

The configuration extraction as currently implemented will not always get all the right configuration for these applets, unless we implement extracting the configuration as a multi way pass: first extract the configuration the way we do now, then search for the names of all the symlinks we have using one of the applets whose name we have been able to extract, then see which names have been recorded into the binary and extract those.

The problem described in 3. can be fixed by adding more information to the tool. This would be done by extracting configuration information from the original busybox sources and generate a lookup table. This will not work if custom applets have been added to busybox.

The information for 2 and 3 can also be found in a configured source code tree by looking at \texttt{include/applet\_tables.h}.

Detecting features is really hard to do in a generic way. In most cases it will
even be impossible, because there are no clear markers (strings, applet names)
in the binary that indicate that a certain feature is enabled. In cases there
are clear marker strings these would still need to be linked to specific
features. One possibility would be to parse the BusyBox sources and link
strings to features, for example (from busybox 1.15.3,
\texttt{editors/diff.c}):

\begin{verbatim}
#if ENABLE_FEATURE_DIFF_DIR
       diffdir(f1, f2);
       return exit_status;
#else
       bb_error_msg_and_die("no support for directory comparison");
#endif
\end{verbatim}

The string \texttt{"no support for directory comparison"} only appears if the
feature \texttt{ENABLE\_FEATURE\_DIFF\_DIR} is not enabled.

Implementing this will be a lot of work and it will likely not be very useful.

\subsubsection{Feeding information into the tool}

By referencing with information extracted from the standard BusyBox sourcecode
it is possible to get a far more accurate configuration, because it is known
which applets use which configuration, unless:

\begin{itemize}
\item new applets were added to BusyBox
\item applets use old names, but contain different code
\end{itemize}

The names of applets that are defined in BusyBox serve as a very good starting
point. How these are recorded in the sources has changed a few times and
depends on the version of BusyBox. The tool \texttt{appletname-extractor.py}
can extract these from the BusyBox sources and store them for later reference
as a simple lookup table in Python pickle format.

Names of applets per version breakdown:

\begin{itemize}
\item 1.15.x and later: \texttt{include/applets.h} IF syntax
\item 1.1.1-1.14.x: \texttt{include/applets.h} USE syntax
\item 1.00-1.1.0: \texttt{include/applets.h} (different syntax)
\item 0.60.5 and earlier: \texttt{applets.h}, like 1.00-1.1.0 but with a slightly different syntax
\end{itemize}

In 1.1.0 there is actually a mix of three different syntaxes: (0.60.5, 1.00 and another) for a few applets (runlevel, watchdog, tr). It takes some extra work to recognize these.

There are also a few applets in 1.1.0 which are a bit harder to detect:
\texttt{busybox}, \texttt{mkfs.ext3}, \texttt{e3fsck} and \texttt{[[}. These
could be added by hand, since there are just four of them.

Another issue that is currently unresolved is that not all the shells are correctly recognized.

\section{Binary Analysus Tool extratools collection}

To help with unpacking non-standard file systems, or standard file systems for
which there are no tools readily available on Fedora or Ubuntu there is also
a collection of tools that can be used by BAT to unpack more file systems.
These tools are not part of the standard distribution, but have to be installed
separately. They are governed by different license conditions than the core BAT
distribution.

Currently the collection consists of:

\begin{itemize}
\item modified version of \texttt{cramfsck} that enables unpacking cramfs
file systems
\item unmodified version of \texttt{unyaffs} that enables unpacking for some
(but not all) YAFFS2 file systems.
\item various versions of \texttt{unsquashfs} that enable unpacking variants
of SquashFS. These versions have either been lifted from vendor SDKs, the
OpenWrt project, or upstream SquashFS project.
\end{itemize}

\section{Binary Analysis Tool knowledgebase}

BAT comes with a mechanism to use a database backend. The default version of
BAT only unpacks file systems and compressed files and runs a few simple checks
on the leaf nodes of the unpacking process.

In the paper "Finding Software License Violations Through Binary Code Clone
Detection" by Hemel et. al. (ACM 978-1-4503-0574-7/11/05) presented at
the Mining Software Repositories 2011 conference a method to use a database
with strings extracted from source code was described. This functionality is
is available in the ranking module in the file \texttt{ranking.py}. This code
is not enabled by default, but it has to be explicitely enabled in the
configuration for \texttt{bruteforce.py}.

To give good results the database that is used needs to be populated with as
many packages as possible, from a cross cut of all of open source software, to
prevent bias towards certain packages: if you only would have BusyBox in your
database, everything would look like BusyBox.

To populate the database you need to download and process open source packages.
Be aware that this is a costly operation: a download of all source packages of
a snapshot of Debian (which would give you a few versions for most packages) is
about 60 GiB. Together with all of GNU, GNOME, most BusyBox versions, and a few
versions of KDE you have about 100 GiB of compressed source code archives.
Processing these files (including licensing information) will take a long time
and the resulting database will also be quite big (at least around 20 GiB).

If you don't want to spend much time on downloading packages and processing
these packages, please contact Tjaldur Software Governance Solutions for
purchasing a copy of a fully preprocessed database at \url{info@tjaldur.nl}.

\subsection{Crawling FTP mirrors}

In the directory \texttt{crawlers} a sample crawler is given for downloading
source packages from the GNU project. The code is fairly straightforward. The
script (written in Python) tries to intelligently download packages from a GNU
FTP mirror, skipping packages that are in a blacklist (either parts of the
filename, whole directories, or extensions) or that have already been
downloaded in the past.

The default configuration points to a mirror in the Netherlands. It is advised
to update the location of the GNU mirror in the configuration file. Specifying
a local mirror will result in faster downloads. It will also not put an
unnecessary strain on the FTP mirror mentioned in the default configuration
file.

\subsection{Generating the package list}

The code and license extractor wants a description file of which packages to
process. This file is hardcoded to \texttt{LIST} relative to the directory that
contains all source archives. The reason there is a specific file is that some
packages do not follow a consistent naming scheme. By using this extra file we
can cleanup names and make sure that source code archives are recognized
correctly.

The file contains four values per line:

\begin{itemize}
\item name
\item version
\item archivename
\item origin (or ``unknown'' if not specified)
\end{itemize}

separated by whitespace (spaces or tabs). An example would look like this:

\begin{verbatim}
amarok	2.3.2	amarok-2.3.2.tar.bz2	kde
\end{verbatim}

This line says that the package is \texttt{amarok}, the version number is
\texttt{2.3.2}, the filename is \texttt{amarok-2.3.2.tar.bz2} and the file
was downloaded from the KDE project.

There is a helper script (\texttt{generatelist.py}) to help generate the file.
It can be invoked as follows:

\begin{verbatim}
python generatelist.py -f /path/to/directory/with/sources
\end{verbatim}

The output is printed on standard output, so you want to redirect it to a file
called \texttt{LIST} (as expected by the string extraction script) and
optionally sorting it first:

\begin{verbatim}
python generatelist.py -f /path/to/directory/with/sources | sort >
   /path/to/directory/with/sources/LIST
\end{verbatim}


\texttt{generatelist.py} tries to determine the name of the package by
splitting the file name on the right if it encounters a \texttt{-} (dash)
character. This is not always done correctly because a package uses multiple
dashes, or because it does not contain a dash. In the latter case an error
will be printed on standard error, informing you that a file could not be
added to the list of packages and it should be added manually.

It is advised to manually inspect the file after generating it to ensure the
correctness of the package names. Packages can have been renamed for a number
of reasons:

\begin{itemize}
\item upstream projects decided to use a new name for archives (abiword
archives for example were renamed from \texttt{abi-\$VERSION.tar.gz} to
\texttt{abiword-\$VERSION.tar.gz}).
\item a distribution has renamed packages to avoid clashes during installation
and allow different versions to be installed next to eachother.
\end{itemize}

In these cases you need to change the names of the packages, otherwise
different versions of the same package will be recorded in the database as
different packages, which will confuse the rating algorithm and cause it to
give suboptimal results.


\subsection{Running the extraction program}

The program to extract strings from sourcecode is
\texttt{batchextractprogramstrings.py}. It parses the file generated by
\texttt{generatelist.py}, unpacks the files (currently only \texttt{tar.gz}
and \texttt{tar.bz2} files, plus variants are supported) and scans each
individual source code file (at the moment just C/C++ files, assembler files,
Java/Scala files and ActionScript files) for strings and, if enabled, licenses.

\texttt{batchextractprogramstrings.py} internally uses \texttt{xgettext} to
extract all strings between double quotes from source code. These are the
strings that are likely to end up in a binary, such as console messages, error
messages or messages and so on. \texttt{batchextractprogramstrings.py} simply
invokes \texttt{xgettext} and parses the results.

\begin{verbatim}
python batchextractprogramstrings.py -f
    /path/to/directory/with/files -d /path/to/database
\end{verbatim}

\subsection{License scanning}

\texttt{batchextractprogramstrings.py} has a few commandline options. The most
important is whether or not to also extract licenses from the source code files.
License extraction is done using the Ninka license scanner, with support
for the Nomos license scanner from FOSSology being added in the near future.
This option is disabled by default for a few reasons:

\begin{itemize}
\item scanning licenses adds a significant performance penalty to scanning the
code (about 1100\% when scanning uClibc 0.9.30.1), even with many
optimizations (like deduplication) in place.
\item there is currently no code in the Binary Analysis Tool that can make use
of this information.
\end{itemize}

If you want to enable license scanning, you will have to install Ninka first
and change a few hardcoded paths in \texttt{batchextractprogramstrings.py} that
point to the main Ninka script.

\subsection{Intelligently making sets of packages when using multiple machines}

One way to tackle the tackle the problem of having to process huge amounts of
source code is to use multiple machines and later merge database. By adding a
little bit of intelligence to preparing the sets of source packages you can
save a lot of processing time. Many packages have duplicate files, especially
if they are just different versions of the same package. A minor patch version
could differ as little as one file. If the extractor already has seen a file, it
will not scan it again, so it makes sense to have as many similar packages
scanned on the same machine, for example all versions of a single package. If
license scanning is enabled it makes sense to have as many packages from the
same project scanned on the same machine, since coding styles often result in
identical license statements, which the scanner already takes into account.

\subsection{Enabling the database}

Currently the database is hardcoded to \texttt{/tmp/master}. It can be changed
in \texttt{ranking.py} in the following line:

\begin{verbatim}
  conn = sqlite3.connect(os.environ.get('BAT_SQLITE_DB', '/tmp/master'))
\end{verbatim}

In the future it will be possible to set the location of the database in the
configuration file for \texttt{bruteforce.py}.

\end{document}
