  Brute force scanning

Top level reporting:
* cryptographic checksum (sha256) of the file
* file name of the scanned file
* scan date plus time

Per directory:
* full name of directory within the firmware
* file listing (similar to ls -laR) after unpacking (this might skip things like device files)

Per file:
* file name
* full path within the firmware
* file type (determined with libmagic)
* sha256sum
* libraries that are linked to (if the file is a dynamic library or binary)
* packages found in the binary

plus any other checks that are deemed necessary.

The searching program can be parameterised by supplying a list of checks that should be performed. This list also acts as a filter: only checks in the list will be checked for and reported. This way it is fairly easy to cherrypick checks you are interested in. Right now this does not work and all checks in the bruteforce configuration file are performed.

The brute force scanner reads a list in a simple format, namely the same as .ini on Windows:

[busybox-version]
type    = program
module  = busybox
method  = extract_version

[gzip-unpack]
type    = unpack
module  = fwunpack
method  = unpackGzip
magic   = gzip
cleanup = cleanupGzip

Each section defines the checks that we are interested in. If no list is given, then all checks are applied. The list is divided in two parts: unpacking of file systems and compressed files and program specific checks.

  program

"program" works on files. The result is a report which can be processed later by a pretty printer. This pretty printer is also dependent on the program. For example busybox needs different reporting than the Linux kernel which needs different reporting than Qt.

  unpack

"unpack" works on various compressed files or file systems and returns a directory that can be traversed by other scripts. An optional cleanup action is needed for cleaning up, or unmounting FUSE file systems.
